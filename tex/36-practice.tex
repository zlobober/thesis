\chapter{Практические результаты}

Автором были программно реализованы 4 алгоритма: 

\begin{itemize}
\item алгоритм \ref{alg:main}, работающий за $\OO(|V|^8)$;
\item алгоритм \ref{alg:n7}, работающий за $\OO(|V|^7)$;
\item алгоритм \ref{alg:n6}, работающий за $\OO(|V|^6)$;
\item переборный алгоритм \ref{alg:brute}, работающий за экспоненциально большое время ${\OO(2^{|V|} \cdot |V|)}$, и не полагающийся на результат теоремы \ref{main_theorem}.
\end{itemize}

\begin{algorithm}
\caption{Вычисление всех значений $2DSP(s_1, t_1, s_2, t_2)$ за $O(2^{|V|} \cdot |V|)$} \label{alg:brute}
\begin{algorithmic}[1]
\Procedure{CalculateAll2DSPValues}{$V$, $E$}
\State $l \gets \text{матрица попарных расстояний между вершинами в }G$; \label{line:floyd}
\For{$s_1, t_1, s_2, t_2, \in V$}
    \State $2DSP(s_1, t_1, s_2, t_2) = \textsc{CalculateSingle2DSPValue}(s_1, t_1, s_2, t_2)$;
\EndFor
\EndProcedure
\Statex
\Procedure{CalculateSingle2DSPValue}{$s_1$, $t_1$, $s_2$, $t_2$}
\State $2DSP(s_1, t_1, s_2, t_2) \gets 0$;
\For{$P\text{ --- кратчайший путь между }s_1\text{ и }t_1$}
    \If {$\text{расстояние между }s_2\text{ и }t_2\text{ в }G \sm P = l(s_2, t_2)$}
        \State $2DSP(s_1, t_1, s_2, t_2) \gets 1$;
    \EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

Все указанные алгоритмы были реализованы в единой программе, что даёт возможность одновременного запуска всех решений на одном и том же графе $G$ (либо заданном вручную, либо сгенерированном из некоторого случайного распределения) и проверки, что на всевозможных четвёрках вершин $(s_1, t_1, s_2, t_2)$ значения предиката $2DSP(s_1, t_1, s_2, t_2)$, вычисленные всеми алгоритмами, совпадают.

Тестирующая программа была запущена на всевозможных пронумерованных связных графах вплоть до $8$ вершин, в процессе чего было найдено немалое число опечаток в программном коде, реализующем формулы \eqref{eq:Q2}. Так как количество связных пронумерованных графов на $9$ вершинах уже превышает $6 \cdot 10^{10}$, экспериментальная проверка корректности полученных на всевозможных связных графах размера более 8 в один поток вычислений не представляется возможной.

Далее тестирующая программа была запущена в $10^4$ экземплярах на вычислительном кластере компании Яндекс, каждый из которых перебирал $10^5$ случайных связных графов на $10$ вершинах и проверял, что перечисленные алгоритмы дают одинаковые результаты. В процессе подобного интенсивного тестирования автором были обнаружены ещё несколько опечаток в программной реализации алгоритма \ref{alg:main} и его оптимизированных версий. Интересной деталью программных ошибок было то, что они были сосредоточены в точности в части программы, отвечающей самому тяжёлому с вычислительной точки зрения случаю жёсткой четвёрки вершин $(s_1, t_1, s_2, t_2)$ (формулы \eqref{eq:Q4}). Таким образом, можно утверждать, что минимальный размер графа, на котором оставление только значений, сгруппированных в величину $Q_2(s_1, t_1, s_2, t_2)$ нарушает корректность алгоритма, находится между $9$ и $10$. Пример <<сложного>> графа размера $10$ приведён на изображении xxx. 

После исправления всех программных ошибок в аналогичном режиме было произведено тестирование в $10^4$ экземплярах на $1000$ графах размера $20$ (без использования алгоритма \ref{alg:brute}) и на $100$ графах размера $30$ (без использования алгоритмов \ref{alg:brute}, \ref{alg:n6}), которое уже не выявило дальнейших расхождений.


